import { __decorate, __param, __metadata } from 'tslib';
import { InjectionToken, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, EventEmitter, Input, Output, Directive, Pipe, NgModule } from '@angular/core';
import { HttpParams, HttpClient, HttpClientModule } from '@angular/common/http';
import { HighlightModule } from 'ngx-highlightjs';
import { EMPTY } from 'rxjs';
import { publishReplay, refCount, catchError } from 'rxjs/operators';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
const GIST_OPTIONS = new InjectionToken('GIST_OPTIONS');

let CodeLoader = class CodeLoader {
    constructor(_http, _options) {
        this._http = _http;
        this._options = _options;
    }
    /**
     * Get plus code
     * @param id Gist ID
     */
    getCodeFromGist(id) {
        let params;
        if (this.isOAuthProvided()) {
            params = new HttpParams().set('client_id', this._options.clientId).set('client_secret', this._options.clientSecret);
        }
        return this.fetchFile(`https://api.github.com/gists/${id}`, { params, responseType: 'json' });
    }
    /**
     * Get code by URL
     * @param url File raw link
     */
    getCodeFromUrl(url) {
        return this.fetchFile(url, { responseType: 'text' });
    }
    /**
     * Check if OAuth option is provided
     */
    isOAuthProvided() {
        return !!this._options && !!this._options.clientId && !!this._options.clientSecret;
    }
    fetchFile(url, options) {
        // Check if URL is valid
        if (isUrl(url)) {
            return this._http.get(url, options).pipe(
            // Catch response
            publishReplay(1), refCount(), catchError((err) => {
                console.error('[NgxHighlight]: Unable to fetch the URL!', err.message);
                return EMPTY;
            }));
        }
        return EMPTY;
    }
};
CodeLoader.ɵfac = function CodeLoader_Factory(t) { return new (t || CodeLoader)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(GIST_OPTIONS, 8)); };
CodeLoader.ctorParameters = () => [
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [GIST_OPTIONS,] }] }
];
CodeLoader.ɵprov = ɵɵdefineInjectable({ factory: function CodeLoader_Factory() { return new CodeLoader(ɵɵinject(HttpClient), ɵɵinject(GIST_OPTIONS, 8)); }, token: CodeLoader, providedIn: "root" });
CodeLoader = __decorate([ __param(1, Optional()), __param(1, Inject(GIST_OPTIONS)),
    __metadata("design:paramtypes", [HttpClient, Object])
], CodeLoader);
function isUrl(url) {
    const regExp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
    return regExp.test(url);
}

let GistDirective = class GistDirective {
    constructor(_loader) {
        this._loader = _loader;
        this.gistLoad = new EventEmitter();
    }
    set gist(value) {
        if (value) {
            this._loader.getCodeFromGist(value).subscribe((gist) => this.gistLoad.emit(gist));
        }
    }
};
GistDirective.ɵfac = function GistDirective_Factory(t) { return new (t || GistDirective)(ɵngcc0.ɵɵdirectiveInject(CodeLoader)); };
GistDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GistDirective, selectors: [["", "gist", ""]], inputs: { gist: "gist" }, outputs: { gistLoad: "gistLoad" } });
GistDirective.ctorParameters = () => [
    { type: CodeLoader }
];
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], GistDirective.prototype, "gist", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], GistDirective.prototype, "gistLoad", void 0);
GistDirective = __decorate([ __metadata("design:paramtypes", [CodeLoader])
], GistDirective);
let GistFilePipe = class GistFilePipe {
    transform(gist, fileName) {
        return (gist && gist.files && gist.files[fileName]) ? gist.files[fileName].content : null;
    }
};
GistFilePipe.ɵfac = function GistFilePipe_Factory(t) { return new (t || GistFilePipe)(); };
GistFilePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gistFile", type: GistFilePipe, pure: true });

let CodeFromUrlPipe = class CodeFromUrlPipe {
    constructor(_loader) {
        this._loader = _loader;
    }
    transform(url) {
        return this._loader.getCodeFromUrl(url);
    }
};
CodeFromUrlPipe.ɵfac = function CodeFromUrlPipe_Factory(t) { return new (t || CodeFromUrlPipe)(ɵngcc0.ɵɵdirectiveInject(CodeLoader)); };
CodeFromUrlPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "codeFromUrl", type: CodeFromUrlPipe, pure: true });
CodeFromUrlPipe.ctorParameters = () => [
    { type: CodeLoader }
];
CodeFromUrlPipe = __decorate([ __metadata("design:paramtypes", [CodeLoader])
], CodeFromUrlPipe);

let HighlightPlusModule = class HighlightPlusModule {
};
HighlightPlusModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HighlightPlusModule });
HighlightPlusModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function HighlightPlusModule_Factory(t) { return new (t || HighlightPlusModule)(); }, imports: [[
            HighlightModule,
            HttpClientModule
        ],
        HighlightModule] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CodeLoader, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [GIST_OPTIONS]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GistDirective, [{
        type: Directive,
        args: [{
                selector: '[gist]'
            }]
    }], function () { return [{ type: CodeLoader }]; }, { gistLoad: [{
            type: Output
        }], gist: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GistFilePipe, [{
        type: Pipe,
        args: [{
                name: 'gistFile'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CodeFromUrlPipe, [{
        type: Pipe,
        args: [{
                name: 'codeFromUrl'
            }]
    }], function () { return [{ type: CodeLoader }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HighlightPlusModule, { declarations: function () { return [GistDirective,
        GistFilePipe,
        CodeFromUrlPipe]; }, imports: function () { return [HighlightModule,
        HttpClientModule]; }, exports: function () { return [HighlightModule,
        GistDirective,
        GistFilePipe,
        CodeFromUrlPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HighlightPlusModule, [{
        type: NgModule,
        args: [{
                imports: [
                    HighlightModule,
                    HttpClientModule
                ],
                declarations: [
                    GistDirective,
                    GistFilePipe,
                    CodeFromUrlPipe
                ],
                exports: [
                    HighlightModule,
                    GistDirective,
                    GistFilePipe,
                    CodeFromUrlPipe
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { CodeFromUrlPipe, CodeLoader, GIST_OPTIONS, GistDirective, GistFilePipe, HighlightPlusModule };

//# sourceMappingURL=ngx-highlightjs-plus.js.map